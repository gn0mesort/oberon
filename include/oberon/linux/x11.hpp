/**
 * @file x11.hpp
 * @brief General header for X11 support.
 * @author Alexander Rothman <gnomesort@megate.ch>
 * @date 2023
 * @copyright AGPL-3.0+
 */

#ifndef OBERON_LINUX_X11_HPP
#define OBERON_LINUX_X11_HPP

#include <X11/Xlib-xcb.h>
#include <X11/keysym.h>

#include "../types.hpp"
#include "../memory.hpp"

#include "x11-errors.hpp"
#include "x11-atoms.hpp"
#include "x11-xkb.hpp"
#include "x11-xinput.hpp"


namespace oberon::linux {


namespace event_flag_bits {

  /**
   * @brief A constant representing no event flag bits.
   */
  OBERON_DEFINE_ZERO_BIT(none);

  /**
   * @brief A constant indicating that an event is synthetic.
   * @details A large amount of XCB documentation indicates that, during event polling, the value of
   *          xcb_generic_event_t::response_type must have the 7th bit (128s place) cleared. The reason for this is
   *          that valid X11 events range from 0 (error) to 127. The 7th bit, instead of indicating a further 128
   *          possible values, incidates whether or not the event is "synthetic". A synthetic event is an event
   *          generated by an X11 SendEvent request as opposed to events generated by the server in the usual course
   *          of operation. Therefore, the proper usage of xcb_generic_event_t::response_type is to clear that
   *          bit before interpretting the response_type. This can be achieved by applying the bitwise-and operation
   *          to ~0x80 (i.e., ~128). To make code clearer, this constant is defined so that you may instead write
   *          ~event_flag_bits::synthetic.
   * @see https://www.x.org/releases/current/doc/xproto/x11protocol.html#event_format
   */
  OBERON_DEFINE_BIT(synthetic, 7);

}

// These are defined by https://www.x.org/releases/current/doc/xorg-docs/icccm/icccm.html#WM_NORMAL_HINTS_Property
namespace size_hint_flag_bits {

  /**
   * @brief A constant representing no size hint flag bits.
   */
  OBERON_DEFINE_ZERO_BIT(none);

  /**
   * @brief A constant indicating that the window position is being set by the user.
   */
  OBERON_DEFINE_BIT(user_position, 0);

  /**
   * @brief A constant indicating that the window size is being set by the user.
   */
  OBERON_DEFINE_BIT(user_size, 1);

  /**
   * @brief A constant indicating that the window position is being set by the program.
   */
  OBERON_DEFINE_BIT(program_position, 2);

  /**
   * @brief A constant indicating that the window size is being set by the program.
   */
  OBERON_DEFINE_BIT(program_size, 3);

  /**
   * @brief A constant indicating that the window size hints contain a program selected minimum size for the window.
   */
  OBERON_DEFINE_BIT(program_min_size, 4);

  /**
   * @brief A constant indicating that the window size hints contain a maximum size for the window.
   */
  OBERON_DEFINE_BIT(program_max_size, 5);

  /**
   * @brief A constant indicating that the window size hints contain a resize increment.
   */
  OBERON_DEFINE_BIT(program_resize_increment, 6);

  /**
   * @brief A constant indicating that the window size hints contain an aspect ratio.
   */
  OBERON_DEFINE_BIT(program_aspect, 7);

  /**
   * @brief A constant indicating that the window size hints contain a base size.
   */
  OBERON_DEFINE_BIT(program_base_size, 8);

  /**
   * @brief A constant indicating that the window size hints contain a window gravity setting.
   */
  OBERON_DEFINE_BIT(program_window_gravity, 9);

}

  /**
   * @brief An enumeration of EWMH _NET_WM_STATE actions.
   * @see https://specifications.freedesktop.org/wm-spec/latest/ar01s05.html#idm45763309267456
   */
  enum wm_state_mode : u32 {
    /**
     * @brief A value indicating that _NET_WM_STATE values should be removed.
     */
    OBERON_LINUX_X_NET_WM_STATE_REMOVE = 0,

    /**
     * @brief A value indicating that _NET_WM_STATE values should be added.
     */
    OBERON_LINUX_X_NET_WM_STATE_ADD = 1,

    /**
     * @brief A value indicating that _NET_WM_STATE values should be toggled (i.e., flipped).
     */
    OBERON_LINUX_X_NET_WM_STATE_TOGGLE = 2
  };

  /**
   * @brief An enumeration of EWMH client message source indications.
   * @see https://specifications.freedesktop.org/wm-spec/latest/ar01s09.html#sourceindication
   */
  enum source_indication : u32 {
    /**
     * @brief A value indicating that the application does not support source indication.
     */
    OBERON_LINUX_X_SOURCE_INDICATION_UNSUPPORTED = 0,

    /**
     * @brief A value indicating that the source of a client message is a normal application.
     */
    OBERON_LINUX_X_SOURCE_INDICATION_APPLICATION = 1,

    /**
     * @brief A value indicating that the source of a client message is a pager.
     */
    OBERON_LINUX_X_SOURCE_INDICATION_PAGER = 2
  };

  /**
   * @brief An enumeration of possible _NET_WM_BYPASS_COMPOSITOR values.
   * @see https://specifications.freedesktop.org/wm-spec/latest/ar01s05.html#idm45763309202800
   */
  enum compositor_mode : u32 {
    /**
     * @brief An value indicating that the application does not have a preference about compositing.
     * @details This is the default state.
     */
    OBERON_LINUX_X_NET_WM_BYPASS_COMPOSITOR_NO_PREFERENCE = 0,

    /**
     * @brief A value indicating that the application explicitly wants to bypass compositing.
     * @details This may forcibly disable compositing in the window manager until the the application changes the
     *          value of _NET_WM_BYPASS_COMPOSITOR or the application exits.
     */
    OBERON_LINUX_X_NET_WM_BYPASS_COMPOSITOR_DISABLE = 1,

    /**
     * @brief A value indicating that the application explicitly wants to be handled by a compositor.
     */
    OBERON_LINUX_X_NET_WM_BYPASS_COMPOSITOR_ENABLE = 2
  };


  /**
   * @brief A WM_SIZE_HINTS structure compatible with the X11 protocol.
   * @details libxcb does not provide this type. Therefore, it is provided here.
   *          Additionally, when flags & (size_hints_flag_bits::min_size | size_hints_flag_bits::max_size) is not 0
   *          and (min_width, min_height) is equal to (max_width, max_height) the window is not resizable.
   * @see https://www.x.org/releases/current/doc/xorg-docs/icccm/icccm.html#WM_NORMAL_HINTS_Property
   */
  struct size_hints final {
    /**
     * @brief A set of size_hints_flag_bits values indicating to the window manager how to interpret the
     *        WM_NORMAL_HINTS value.
     */
    u32 flags{ };

    /**
     * @brief Padding values.
     */
    u32 pad[4]{ };

    /**
     * @brief The minimum width of the window.
     */
    i32 min_width{ };

    /**
     * @brief The minimum height of the window.
     */
    i32 min_height{ };

    /**
     * @brief The maximum width of the window.
     */
    i32 max_width{ };

    /**
     * @brief The maximum height of the window.
     */
    i32 max_height{ };

    /**
     * @brief The increment by which the window should grow along the X-axis.
     */
    i32 width_inc{ };

    /**
     * @brief The increment by which the window should grow along the Y-axis.
     */
    i32 height_inc{ };

    /**
     * @brief The minimum X-axis aspect.
     */
    i32 min_aspect_x{ };

    /**
     * @brief The minimum Y-axis aspect.
     */
    i32 min_aspect_y{ };

    /**
     * @brief The maximum X-axis aspect.
     */
    i32 max_aspect_x{ };

    /**
     * @brief The maximum Y-axis aspect.
     */
    i32 max_aspect_y{ };

    /**
     * @brief The base width of the window.
     */
    i32 base_width{ };

    /**
     * @brief The base height of the window.
     */
    i32 base_height{ };

    /**
     * @brief The X11 window gravity assigned to the window.
     */
    i32 win_gravity{ };
  };

  /**
   * @brief The maximum number of event types allowed by X11.
   * @details X11 dictates that events have a response_type field between 0 and 127. The 0 type indicates a protocol
   *          error that was received on the event queue. Events 1 to 63 (inclusive) are core protocol events
   *          (although only 33 are actually used). Events 64 to 127 are reserved for extensions.
   * @see https://www.x.org/releases/current/doc/xproto/x11protocol.html#event_format
   */
  constexpr const usize OBERON_LINUX_X_EVENT_MAX{ 128 };

  /**
   * @brief A structure representing the state of a keyboard key.
   */
  struct key_state final {
    /**
     * @brief Whether or not the key is pressed.
     */
    bool pressed{ };

    /**
     * @brief Whether or not the key is sending echo press events.
     */
    bool echo{ };
  };

  struct button_state final {
    bool pressed{ };
  };

}

#endif
